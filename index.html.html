<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Air Hockey - Dark Mode</title>
    <style>
        /* --- Dark Mode Aesthetic & CSS Reset --- */
        body {
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #0a0a0a; /* Deep Charcoal Background */
            color: #e0e0e0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
        }

        #game-container {
            position: relative;
            box-shadow: 0 0 30px rgba(0, 195, 255, 0.2);
            border-radius: 12px;
            overflow: hidden;
        }

        canvas {
            display: block;
            background: #121212; /* Dark Arena Floor */
            cursor: none; /* Hide default cursor inside game */
        }

        #ui-layer {
            position: absolute;
            top: 20px;
            width: 100%;
            display: flex;
            justify-content: space-around;
            font-size: 32px;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
            pointer-events: none;
        }

        .score-ai { color: #ff4d4d; text-shadow: 0 0 15px #ff4d4d; } /* Neon Red */
        .score-player { color: #00c3ff; text-shadow: 0 0 15px #00c3ff; } /* Neon Blue */

        #overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            display: none; /* Hidden by default */
        }

        #overlay h1 {
            font-size: 48px;
            margin-bottom: 20px;
            text-shadow: 0 0 20px #ffffff;
        }
        
        #overlay p { font-size: 20px; color: #aaa; }
    </style>
</head>
<body>

    <div id="game-container">
        <div id="ui-layer">
            <div class="score-ai">AI: <span id="aiScore">0</span></div>
            <div class="score-player">YOU: <span id="playerScore">0</span></div>
        </div>
        <canvas id="gameCanvas" width="450" height="700"></canvas>

        <div id="overlay">
            <h1 id="winnerText">YOU WIN!</h1>
            <p>Click to restart</p>
        </div>
    </div>

<script>
// ==========================================
//  STRUCTURAL & CONCRETE AIR HOCKEY ENGINE
// ==========================================

// --- Constants & Configuration ---
const CONSTANTS = {
    WIN_SCORE: 3,
    FRICTION: 0.985, // Air cushion effect
    WALL_BOUNCE: 0.85, // Energy loss hitting walls
    MAX_SPEED: 18,
    AI_SPEED_FACTOR: 0.09, // Lower = slower reaction (lerp)
    COLORS: {
        BG: '#121212',
        PLAYER: '#00c3ff',
        AI: '#ff4d4d',
        PUCK: '#ffffff',
        LINES: '#333333'
    }
};

// --- 1. Vector Math Utility Class ---
class Vector {
    constructor(x, y) { this.x = x; this.y = y; }
    add(v) { return new Vector(this.x + v.x, this.y + v.y); }
    sub(v) { return new Vector(this.x - v.x, this.y - v.y); }
    mult(n) { return new Vector(this.x * n, this.y * n); }
    mag() { return Math.sqrt(this.x * this.x + this.y * this.y); }
    normalize() {
        let m = this.mag();
        if (m > 0) return this.mult(1 / m);
        return new Vector(0, 0);
    }
    static dist(v1, v2) { return v1.sub(v2).mag(); }
}

// --- 2. Game Object Classes ---

class Puck {
    constructor(cw, ch) {
        this.radius = 18;
        this.reset(cw, ch);
        this.flashIntensity = 0; // For visual effect
    }

    reset(cw, ch) {
        this.pos = new Vector(cw / 2, ch / 2);
        this.vel = new Vector(0, 0);
    }

    update() {
        // Physics: Movement & Friction
        this.pos = this.pos.add(this.vel);
        this.vel = this.vel.mult(CONSTANTS.FRICTION);

        // Speed Cap (Tunneling prevention)
        if (this.vel.mag() > CONSTANTS.MAX_SPEED) {
            this.vel = this.vel.normalize().mult(CONSTANTS.MAX_SPEED);
        }
        // Visual flash fade out
        if(this.flashIntensity > 0) this.flashIntensity -= 0.1;
    }

    checkBounds(cw, ch) {
        let hitWall = false;
        // Left/Right Walls
        if (this.pos.x - this.radius < 0) {
            this.pos.x = this.radius;
            this.vel.x *= -CONSTANTS.WALL_BOUNCE;
            hitWall = true;
        } else if (this.pos.x + this.radius > cw) {
            this.pos.x = cw - this.radius;
            this.vel.x *= -CONSTANTS.WALL_BOUNCE;
            hitWall = true;
        }
        // Top/Bottom Walls (Bounce only if not goal area)
        // Simple goal check: if it passes top/bottom edge completely
        if (this.pos.y < -this.radius || this.pos.y > ch + this.radius) {
             // Goal scored - handled by Game Manager
        } else if ((this.pos.y - this.radius < 0 && (this.pos.x < cw*0.3 || this.pos.x > cw*0.7)) || 
                   (this.pos.y + this.radius > ch && (this.pos.x < cw*0.3 || this.pos.x > cw*0.7))) {
             // Bounce off back walls outside goal area
             this.vel.y *= -CONSTANTS.WALL_BOUNCE;
             hitWall = true;
        }

        if(hitWall) this.flashIntensity = 1.0;
    }
}

class Mallet {
    constructor(x, y, isAI) {
        this.pos = new Vector(x, y);
        this.radius = 30;
        this.isAI = isAI;
        this.color = isAI ? CONSTANTS.COLORS.AI : CONSTANTS.COLORS.PLAYER;
    }

    update(targetPos, cw, ch) {
        if (this.isAI) {
            // Simple AI: Lerp towards puck x, stay on own half y
            let destX = targetPos.x;
            let destY = Math.max(targetPos.y, 50); // Don't go too far back
            // Only move if puck is in AI half (top half)
            if (targetPos.y > ch/2) {
                 destX = cw/2;
                 destY = ch/4;
            }

            this.pos.x += (destX - this.pos.x) * CONSTANTS.AI_SPEED_FACTOR;
            this.pos.y += (destY - this.pos.y) * CONSTANTS.AI_SPEED_FACTOR;
        } else {
            // Player follows mouse directly
            this.pos = targetPos;
        }
        this.constrain(cw, ch);
    }

    constrain(cw, ch) {
        // Keep mallet within bounds and on its side of court
        this.pos.x = Math.max(this.radius, Math.min(cw - this.radius, this.pos.x));
        if (this.isAI) {
            this.pos.y = Math.max(this.radius, Math.min(ch / 2 - this.radius, this.pos.y));
        } else {
            this.pos.y = Math.max(ch / 2 + this.radius, Math.min(ch - this.radius, this.pos.y));
        }
    }
}

// --- 3. Main Game Manager (The Controller) ---
class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.cw = this.canvas.width;
        this.ch = this.canvas.height;

        this.puck = new Puck(this.cw, this.ch);
        this.aiMallet = new Mallet(this.cw / 2, 100, true);
        this.playerMallet = new Mallet(this.cw / 2, this.ch - 100, false);

        this.score = { player: 0, ai: 0 };
        this.gameState = 'playing'; // playing, goalReset, gameOver

        this.mousePos = new Vector(this.cw / 2, this.ch - 100);
        this.setupInput();
        this.loop();
    }

    setupInput() {
        this.canvas.addEventListener('mousemove', (e) => {
            const rect = this.canvas.getBoundingClientRect();
            // Map mouse coordinates to canvas scale
            const scaleX = this.canvas.width / rect.width;
            const scaleY = this.canvas.height / rect.height;
            this.mousePos.x = (e.clientX - rect.left) * scaleX;
            this.mousePos.y = (e.clientY - rect.top) * scaleY;
        });
        
        document.getElementById('overlay').addEventListener('click', () => {
            if(this.gameState === 'gameOver') this.resetGame();
        });
    }

    handleCollisions() {
        [this.playerMallet, this.aiMallet].forEach(mallet => {
            let dist = Vector.dist(this.puck.pos, mallet.pos);
            if (dist < this.puck.radius + mallet.radius) {
                // Visual Flash (User Feedback Request #2)
                this.puck.flashIntensity = 1.0;

                // 1. Resolve overlap (push puck out)
                let overlap = (this.puck.radius + mallet.radius) - dist;
                let dir = this.puck.pos.sub(mallet.pos).normalize();
                this.puck.pos = this.puck.pos.add(dir.mult(overlap));

                // 2. Physics Impulse Transfer
                // Simple but effective: transfer mallet velocity + bounce
                let impulsePower = 1.1; // Slightly increase power
                this.puck.vel = dir.mult(impulsePower * Math.max(5, this.puck.vel.mag())); 
                // Ensure minimum speed on hit so it doesn't stick
            }
        });
    }

    checkGoal() {
        if (this.puck.pos.y < -this.puck.radius * 2) {
            this.scoreGoal('player');
        } else if (this.puck.pos.y > this.ch + this.puck.radius * 2) {
            this.scoreGoal('ai');
        }
    }

    scoreGoal(winner) {
        this.score[winner]++;
        this.updateUI();
        this.gameState = 'goalReset';
        
        if (this.score[winner] >= CONSTANTS.WIN_SCORE) {
            this.gameState = 'gameOver';
            this.showGameOver(winner === 'player' ? "YOU WIN!" : "AI WINS!");
        } else {
            setTimeout(() => {
                this.puck.reset(this.cw, this.ch);
                this.gameState = 'playing';
            }, 1500); // 1.5s delay before restart
        }
    }

    updateUI() {
        document.getElementById('aiScore').textContent = this.score.ai;
        document.getElementById('playerScore').textContent = this.score.player;
    }
    
    showGameOver(text) {
        const overlay = document.getElementById('overlay');
        document.getElementById('winnerText').textContent = text;
        overlay.style.display = 'flex';
    }

    resetGame() {
        this.score = { player: 0, ai: 0 };
        this.updateUI();
        this.puck.reset(this.cw, this.ch);
        document.getElementById('overlay').style.display = 'none';
        this.gameState = 'playing';
    }

    render() {
        // Clear & Background
        this.ctx.fillStyle = CONSTANTS.COLORS.BG;
        this.ctx.fillRect(0, 0, this.cw, this.ch);

        // Draw Field Lines (Neon Style)
        this.ctx.strokeStyle = CONSTANTS.COLORS.LINES;
        this.ctx.lineWidth = 4;
        this.ctx.shadowBlur = 10;
        this.ctx.shadowColor = CONSTANTS.COLORS.LINES;
        this.ctx.beginPath();
        this.ctx.moveTo(0, this.ch / 2); this.ctx.lineTo(this.cw, this.ch / 2); // Center Line
        this.ctx.stroke();
        this.ctx.beginPath();
        this.ctx.arc(this.cw/2, this.ch/2, 50, 0, Math.PI*2); // Center Circle
        this.ctx.stroke();
        this.ctx.shadowBlur = 0; // Reset shadow

        // Helper function to draw circles
        const drawCircle = (obj, color, glow) => {
            this.ctx.beginPath();
            this.ctx.arc(obj.pos.x, obj.pos.y, obj.radius, 0, Math.PI * 2);
            this.ctx.fillStyle = color;
            if(glow) {
                 this.ctx.shadowBlur = 20;
                 this.ctx.shadowColor = color;
            }
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
            this.ctx.closePath();
        };

        // Draw Mallets
        drawCircle(this.aiMallet, CONSTANTS.COLORS.AI, true);
        drawCircle(this.playerMallet, CONSTANTS.COLORS.PLAYER, true);

        // Draw Puck with collision flash
        let puckColor = CONSTANTS.COLORS.PUCK;
        if(this.puck.flashIntensity > 0) {
            // Mix white flash based on intensity
            puckColor = `rgba(255, 255, 255, ${0.8 + this.puck.flashIntensity*0.2})`;
             this.ctx.shadowBlur = 30 * this.puck.flashIntensity;
             this.ctx.shadowColor = 'white';
        }
        drawCircle(this.puck, puckColor, false);
         this.ctx.shadowBlur = 0;
    }

    loop() {
        if (this.gameState === 'playing') {
            this.playerMallet.update(this.mousePos, this.cw, this.ch);
            this.aiMallet.update(this.puck.pos, this.cw, this.ch);
            this.puck.update();
            this.puck.checkBounds(this.cw, this.ch);
            this.handleCollisions();
            this.checkGoal();
        }
        this.render();
        requestAnimationFrame(() => this.loop());
    }
}

// --- Start Game ---
window.onload = () => new Game();

</script>
</body>
</html>